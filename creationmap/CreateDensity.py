# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CreationMap
                                 A QGIS plugin
 Density population map creation by region
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-18
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Althéa Feuillet
        email                : althea.feuillet@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.core import (QgsExpression, QgsCoordinateTransform, QgsFeatureRequest, QgsProject, 
                       QgsCoordinateReferenceSystem, QgsField)
from qgis import processing

class CreateDensity:
    @staticmethod
    def selectRegions(dlg, municipality):
        """
        Sélectionne les entités de la couche des municipalités en fonction des régions choisies dans la boîte de dialogue.

        :param dlg: La boîte de dialogue de l'application.
        :type dlg: CreationMapDialog
        :param municipality: La couche des municipalités.
        :type municipality: QgsVectorLayer

        :return: La couche résultante avec les entités sélectionnées.
        :rtype: QgsVectorLayer

        Sélectionne les entités de la couche des municipalités en fonction des régions choisies dans la boîte de dialogue.
        Ensuite, clone les entités sélectionnées dans une nouvelle couche.

        """
        try:
            if not dlg.comboBoxRegions.checkedItems():
                QMessageBox.warning(None, 'Avertissement', 'Veuillez sélectionner au moins une région.')
                return None
            
            # Crée une expression pour sélectionner les entités en fonction des régions
            regions_exp = QgsExpression('region IN ({})'.format(','.join("'{0}'".format(region) for region in dlg.comboBoxRegions.checkedItems())))

            # Utilise l'expression pour sélectionner les entités dans la couche des municipalités clonée
            selected_features = [f.id() for f in municipality.getFeatures(QgsFeatureRequest(regions_exp))]
            municipality.selectByIds(selected_features)

            # Clone les entités sélectionnées dans une nouvelle couche
            selected_layer = municipality.materialize(QgsFeatureRequest().setFilterFids(selected_features))

            municipality.removeSelection()

            return selected_layer
            
        except Exception as e:
            QMessageBox.critical(None, 'Erreur', f'Erreur lors de la jointure des couches : {str(e)}')
            return None

    @staticmethod
    def joinItems(dlg):
        """
        Effectue une jointure attributaire entre la couche des municipalités et la couche de population.

        :param dlg: La boîte de dialogue de l'application.
        :type dlg: CreationMapDialog

        :return: La couche résultante de la jointure.
        :rtype: QgsVectorLayer

        Effectue une jointure attributaire entre la couche des municipalités et la couche de population.

        """
        try:
            # Obtient les champs choisis dans les combobox
            municipality_field = str(dlg.comboBoxMunicipality.currentText())
            population_field = str(dlg.comboBoxPopulation.currentText())
        
            params = {
                'DISCARD_NONMATCHING' : False, 
                'FIELD' : municipality_field, 
                'FIELDS_TO_COPY' : [], 
                'FIELD_2' : population_field, 
                'INPUT' : dlg.lineMunicipality.text(), 
                'INPUT_2' : dlg.linePopulation.text(), 
                'METHOD' : 1, 
                'OUTPUT' : 'TEMPORARY_OUTPUT', 
                'PREFIX' : '' 
            }

            result = processing.run("native:joinattributestable", params)

            # Obtient la couche résultante de la jointure
            return result['OUTPUT']

        except Exception as e:
            QMessageBox.critical(None, 'Erreur', f'Erreur lors de la jointure attributaire : {str(e)}')   
            pass

    @staticmethod
    def calculateDensity(layer):
        """
        Calcule la densité de population pour chaque entité dans la couche.

        :param layer: La couche des entités.
        :type layer: QgsVectorLayer

        :return: La couche résultante avec la densité calculée.
        :rtype: QgsVectorLayer

        Calcule la densité de population pour chaque entité dans la couche.
        La densité est calculée en fonction de la superficie et de la population.

        """
        try:
            # Création des couches de surface et densité
            layer_provider = layer.dataProvider()
            layer.startEditing()
            layer_provider.addAttributes([QgsField("surface", QVariant.Double, len=7,prec=5)])
            layer_provider.addAttributes([QgsField("densité", QVariant.Double, len=7,prec=2)])
            layer.updateFields()
            layer.commitChanges()
            
            # Systèmes de coordonnées utilisés. Nous souhaitons passé d'un EPSG 4326 à un EPSG 3857
            # Nous souhaitons faire les calculs de l'aire en EPSG 3857 car l'unité de ce système est en mètres
            # (et il est en degrès pour l'EPSG 4326)
            crs_4326 = QgsCoordinateReferenceSystem('EPSG:4326')
            crs_3857 = QgsCoordinateReferenceSystem('EPSG:3857')
            
            layer.startEditing()
            for feature in layer.getFeatures():
                try:
                    geom = feature.geometry() 
                    # Permet de mettre à jour le système de coordonnée de chaque feature
                    geom.transform(QgsCoordinateTransform(crs_4326, crs_3857, QgsProject.instance()))
                    feature.setGeometry(geom)
                    layer.updateFeature(feature)
                    
                    # Calcul de l'aire
                    area = feature.geometry().area() / 1000000
                    feature["surface"] = round(area, 5)
                    layer.updateFeature(feature)
                    
                    # Calcul de la densité
                    population = float(feature["ptot"]) if feature["ptot"] is not None else 0 
                    feature["densité"] = round(population / feature["surface"], 2)
                    layer.updateFeature(feature)
   
                except (ValueError, TypeError, ZeroDivisionError) as e:
                    feature["densité"] = None
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("densité"), None)
                    layer.updateFeature(feature)

            layer.commitChanges()
            
            return layer

        except Exception as e:
            QMessageBox.critical(None, 'Erreur', f'Erreur lors du calcul de la densité : {str(e)}')